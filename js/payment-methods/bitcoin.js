var app = app || {};

app.paymentMethods = app.paymentMethods || {};

app.paymentMethods.bitcoin = (function() {

	'use strict';

	return app.abstracts.PaymentMethod.extend({

		enabled: true,

		// The name of the cryptocurrency shown in the UI:
		label: 'Bitcoin',

		// The exchange symbol:
		code: 'BTC',

		// Used internally to reference itself:
		ref: 'bitcoin',

		// Used to generate a payment request URI:
		uriScheme: 'bitcoin',

		// Used when formatting numbers (to be displayed in the UI).
		numberFormat: {
			decimals: 8,
		},

		verificationInstructions: function() {
			return app.i18n.t(this.ref + '.verificationInstructions');
		},

		lang: {
			'en': {
				'verificationInstructions': 'Please compare the following addresses with those generated by your wallet application.',
				'settings.addressIndex.label': 'Address Index',
				'settings.addressIndex.description': 'This is the starting number (zero-based) from which new addresses will be generated.',
				'settings.addressIndex.integer-required': 'Must be an integer',
				'settings.addressIndex.greater-than-or-equal-zero': 'Must be greater than or equal to zero',
				'settings.extendedPublicKey.label': 'Extended Public Key',
				'settings.extendedPublicKey.description': 'Used to generate a new receiving address every time you request a payment',
				'invalid-checksum': 'Invalid checksum',
				'invalid-derivation-scheme': 'Invalid derivation scheme',
				'invalid-extended-public-key': 'Invalid extended public key. Are you sure it is for {{paymentMethodLabel}}?',
				'unknown-extended-public-key-prefix': 'Unknown extended public key prefix',
				'index-must-be-an-integer': 'Index must be an integer',
				'index-must-be-less-than': 'Index must be less than 2^32',
				'address-type-not-supported': 'Address type ("{{type}}") not supported',
				'insufficient-funds-to-make-payment': 'Not enough funds to make payment.',
				'invalid-wif': 'Invalid private key. Are you sure it is for {{paymentMethodLabel}}?',
				'private-keys-warning': 'WARNING: Do NOT use private keys with this app!',
			},
			'de': {
				'verificationInstructions': 'Bitte vergleichen Sie die folgenden Adressen mit denen, die von Ihrer Wallet generiert wurden.',
				'settings.addressIndex.label': 'Adressen Index',
				'settings.addressIndex.description': 'Dies ist die Startnummer (null-basiert), aus der neue Adressen generiert werden.',
				'settings.addressIndex.integer-required': 'Muss eine Ganzzahl sein',
				'settings.addressIndex.greater-than-or-equal-zero': 'Muss größer oder gleich 0 sein',
				'settings.extendedPublicKey.label': 'Extended Public Key',
				'settings.extendedPublicKey.description': 'Wird verwendet, um bei jeder Zahlung eine neue Empfängeradresse zu generieren',
				'invalid-checksum': 'Ungültige Prüfsumme',
				'invalid-derivation-scheme': 'Ungültiges Ableitungsschema (derivation scheme)',
				'index-must-be-an-integer': 'Der Index muss eine Ganzzahl sein',
				'index-must-be-less-than': 'Der Index muss kleiner als 2^32 sein',
				'address-type-not-supported': 'Adresstyp ("{{type}}") wird nicht unterstützt',
				'insufficient-funds-to-make-payment': 'Ihr Guthaben reicht nicht aus.',
				'invalid-wif': 'Ungültiger privater Schlüssel. Sind Sie sicher, dass der Schlüssel für {{paymentMethodLabel}} ist?',
				'private-keys-warning': 'WARNUNG: Verwenden Sie KEINE privaten Schlüssel mit dieser App!',
			},
			'cs': {
				'verificationInstructions': 'Porovnejte prosím následující adresy s těmi, které generuje vaše aplikace peněženky.',
				'settings.addressIndex.label': 'Index adresy',
				'settings.addressIndex.description': 'Toto je počáteční číslo (začínajíc 0), ze kterého budou generovány nové adresy.',
				'settings.addressIndex.integer-required': 'Musí být celé číslo',
				'settings.addressIndex.greater-than-or-equal-zero': 'Musí být větší nebo rovno nule',
				'settings.extendedPublicKey.label': 'Rozšířený veřejný klíč',
				'settings.extendedPublicKey.description': 'Používá se k vygenerování nové adresy při každém zadání platby',
				'invalid-checksum': 'Neplatný kontrolní součet',
				'invalid-derivation-scheme': 'Neplatná schéma odvození',
				'index-must-be-an-integer': 'Index musí být celé číslo',
				'index-must-be-less-than': 'Index musí být menší než 2^32',
				'address-type-not-supported': 'Typ adresy ("{{type}}") ne podporován',
				'insufficient-funds-to-make-payment': 'Není dostatek prostředků na platbu.',
				'invalid-wif': 'Neplatný soukromý klíč. Jste si jisti, že to je pro {{paymentMethodLabel}}?',
				'private-keys-warning': 'UPOZORNĚNÍ: Nepoužívejte s touto aplikací soukromé klíče!',
			},
			'es': {
				'verificationInstructions': 'Compare las siguentes direcciones con las que genera su monedero',
				'settings.addressIndex.label': 'Indice de direcciones',
				'settings.addressIndex.description': 'Número de inicio desde el cual las direcciones van a ser derivadas',
				'settings.addressIndex.integer-required': 'Debe ser un entero',
				'settings.addressIndex.greater-than-or-equal-zero': 'Debe ser mayor o igual que cero',
				'settings.extendedPublicKey.label': 'Clave Pública Extendida',
				'settings.extendedPublicKey.description': 'Usada para derivar una nueva dirección cada vez que genere una solicitud de pago',
				'invalid-checksum': 'Suma de comprobación inválida',
				'invalid-derivation-scheme': 'Esquema de derivación no válido',
				'index-must-be-an-integer': 'El índice debe ser un número entero',
				'index-must-be-less-than': 'El índice debe ser menor que 2^32',
				'address-type-not-supported': 'El tipo de dirección ("{{type}}") no es aceptada',
				'insufficient-funds-to-make-payment': 'Insuficientes fondos para el pago.',
				'invalid-wif': 'Clave privada incorrecta. ¿Seguro que es para {{paymentMethodLabel}}?',
				'private-keys-warning': '¡ADVERTENCIA: NO utilice claves privadas en esta aplicación!',
			},
			'fr': {
				'settings.addressIndex.label': 'Indice d\'adresse',
				'settings.addressIndex.integer-required': 'Doit être un entier',
				'settings.addressIndex.greater-than-or-equal-zero': 'Doit être supérieur ou égal à zéro',
				'settings.extendedPublicKey.label': 'Clé publique étendue',
				'invalid-checksum': 'Somme de contrôle invalide',
				'invalid-derivation-scheme': 'Schéma de dérivation invalide',
				'index-must-be-an-integer': 'L\'index doit être un nombre entier',
				'index-must-be-less-than': 'L\'index doit être inférieur à 2^32',
				'private-keys-warning': 'AVERTISSEMENT: N\'utilisez pas de clés privées avec cette application!',
			},
		},

		settings: [
			{
				name: 'extendedPublicKey',
				label: function() {
					return app.i18n.t('bitcoin.settings.extendedPublicKey.label');
				},
				description: function() {
					return app.i18n.t('bitcoin.settings.extendedPublicKey.description');
				},
				type: 'text',
				required: true,
				validateAsync: function(value, data, cb) {
					var addressIndex = data[this.ref + '.addressIndex'];
					var derivationScheme = data[this.ref + '.derivationScheme'];
					this.deriveAddress(value, derivationScheme, addressIndex, cb);
				},
				actions: [
					{
						name: 'camera',
						fn: function(value, cb) {
							app.device.scanQRCodeWithCamera(cb);
						}
					}
				]
			},
			{
				name: 'addressIndex',
				label: function() {
					return app.i18n.t('bitcoin.settings.addressIndex.label');
				},
				description: function() {
					return app.i18n.t('bitcoin.settings.addressIndex.description');
				},
				type: 'number',
				required: true,
				default: '0',
				validate: function(value, data) {
					value = parseInt(value);
					if (_.isNaN(value)) {
						throw new Error(app.i18n.t('bitcoin.settings.addressIndex.integer-required'));
					}
					if (value < 0) {
						throw new Error(app.i18n.t('bitcoin.settings.addressIndex.greater-than-or-equal-zero'));
					}
				}
			},
			{
				name: 'derivationScheme',
				type: 'text',
				visible: false,
				default: 'm/0/n',
				validate: function(value) {
					this.parseDerivationScheme(value);
				},
			}
		],

		/*
			Network constants.
		*/
		network: {
			bech32: 'bc',
			bip32: {
				public: 76067358,
				private: 76066276
			},
			/*
				Extended-key constants. See:
				https://github.com/spesmilo/electrum-docs/blob/master/xpub_version_bytes.rst
				https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
				https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
				https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
			*/
			extendedPublicKeyPrefixes: {
				xpub: {
					addressType: 'p2pkh',
					hex: '0488b21e',
				},
				ypub: {
					addressType: 'p2wpkh-p2sh',
					hex: '049d7cb2',
				},
				Ypub: {
					addressType: 'p2wsh-p2sh',
					hex: '0295b43f',
				},
				zpub: {
					addressType: 'p2wpkh',
					hex: '04b24746',
				},
				Zpub: {
					addressType: 'p2wsh',
					hex: '02aa7ed3',
				},
			},
			messagePrefix: '\x18Bitcoin Signed Message:\n',
			pubKeyHash: 0,
			scriptHash: 5,
			wif: 128,
		},

		/*
			Information needed for connecting to ElectrumX servers.
		*/
		electrum: {
			defaultPorts: {
				tcp: 50001,
				ssl: 50002,
			},
			servers: [
				'electrumx.paralelnipolis.cz s t',
				'btc.smsys.me s995',
				'E-X.not.fyi s t',
				'electrum.vom-stausee.de s t',
				'electrum.hsmiths.com s t',
				'helicarrier.bauerj.eu s t',
				'hsmiths4fyqlw5xw.onion s t',
				'ozahtqwp25chjdjd.onion s t',
				'node.arihanc.com s t',
				'arihancckjge66iv.onion s t',
			],
		},

		addressTypes: ['p2pkh', 'p2wpkh-p2sh', 'p2wpkh'],

		addressStatusSubscriptions: {},

		createVerificationView: function(cb) {

			this.generateSampleAddresses(_.bind(function(error, addresses) {

				if (error) {
					return cb(error);
				}

				try {
					var view = new app.views.SampleAddresses({
						addresses: addresses,
					});
				} catch (error) {
					return cb(error);
				}

				cb(null, view);

			}, this));
		},

		isExtendedPrivateKey: function(value) {

			return _.isString(value) && value.substr(1, 3) === 'prv';
		},

		getAddressTypeFromExtendedPublicKey: function(extendedPublicKey) {

			var prefix = extendedPublicKey.substr(0, 4);

			if (!this.network.extendedPublicKeyPrefixes[prefix]) {
				throw new Error(app.i18n.t(this.ref + '.invalid-extended-public-key', { paymentMethodLabel: this.label }));
			}

			return this.network.extendedPublicKeyPrefixes[prefix].addressType;
		},

		normalizeExtendedPublicKey: function(extendedPublicKey) {

			// Find the prefix that matches the bip32 public key constant.
			var toPrefix = _.findKey(this.network.extendedPublicKeyPrefixes, function(prefix) {
				var value = parseInt(prefix.hex, 16);
				return !_.isNaN(value) && value === this.network.bip32.public;
			}, this);

			return this.convertExtendedPublicKey(extendedPublicKey, toPrefix);
		},

		convertExtendedPublicKey: function(extendedPublicKey, toPrefix) {

			if (!this.network.extendedPublicKeyPrefixes[toPrefix]) {
				throw new Error(app.i18n.t(this.ref + '.unknown-extended-public-key-prefix'));
			}

			var data = bs58.decode(extendedPublicKey);
			// Remove the current prefix:
			data = data.slice(4);
			// And the current checksum:
			data = data.slice(0, -4);
			// Add the new prefix:
			data = Buffer.concat([
				Buffer.from(this.network.extendedPublicKeyPrefixes[toPrefix].hex, 'hex'),
				data,
			]);
			var checksum = bitcoin.crypto.hash256(data).slice(0, 4);
			// Base58 encode with checksum (ie. "base58check"):
			return bs58.encode(Buffer.concat([
				data,
				checksum,
			], data.length + 4));
		},

		generateSampleAddresses: function(cb) {

			var extendedPublicKey = app.settings.get(this.ref + '.extendedPublicKey');
			var startIndex = parseInt(app.settings.get(this.ref + '.addressIndex') || '0');
			var derivationScheme = app.settings.get(this.ref + '.derivationScheme');
			var sampleAddressesCacheKey = extendedPublicKey + '-' + startIndex + '-' + derivationScheme;
			var sampleAddresses = app.cache.get(sampleAddressesCacheKey);

			if (sampleAddresses) {
				return cb(null, sampleAddresses);
			}

			var iteratee = _.bind(function(index, next) {
				var addressIndex = startIndex + index;
				this.deriveAddress(extendedPublicKey, derivationScheme, addressIndex, function(error, address) {
					if (error) return next(error);
					next(null, {
						index: addressIndex,
						address: address,
					});
				});
			}, this);

			async.times(app.config.numberOfSampleAddressesToShow, iteratee, function(error, addresses) {
				if (error) return cb(error);
				app.cache.set(sampleAddressesCacheKey, addresses);
				cb(null, addresses);
			});
		},

		generatePaymentRequest: function(amount, cb) {

			var uriScheme = this.uriScheme;

			this.getReceivingAddress(function(error, address) {

				if (error) {
					return cb(error);
				}

				var paymentRequest = {
					amount: amount,
					uri: uriScheme + ':' + address + '?amount=' + amount,
					data: {
						address: address,
					},
				};

				cb(null, paymentRequest);
			});
		},

		getReceivingAddress: function(cb) {

			var extendedPublicKey = app.settings.get(this.ref + '.extendedPublicKey');
			var derivationScheme = app.settings.get(this.ref + '.derivationScheme');
			var index = parseInt(app.settings.get(this.ref + '.addressIndex') || '0');
			this.deriveAddress(extendedPublicKey, derivationScheme, index, cb);
		},

		incrementAddressIndex: function(cb) {

			var settingPath = this.ref + '.addressIndex';
			var index = parseInt(app.settings.get(settingPath) || '0');
			var nextIndex = index + 1;
			app.settings.set(settingPath, nextIndex.toString());
			// Defer the callback function so that it is async.
			_.defer(cb);
		},

		deriveAddress: function(extendedPublicKey, derivationScheme, addressIndex, cb) {

			_.defer(_.bind(function() {
				try {
					if (this.isExtendedPrivateKey(extendedPublicKey)) {
						throw new Error(app.i18n.t(this.ref + '.private-keys-warning'));
					}
					var type = this.getAddressTypeFromExtendedPublicKey(extendedPublicKey);
					extendedPublicKey = this.normalizeExtendedPublicKey(extendedPublicKey);
					var constants = this.getNetworkConstants();
					var keyPair = bitcoin.bip32.fromBase58(extendedPublicKey, constants);
					var path = this.getPath(derivationScheme, addressIndex);
					var child = keyPair.derivePath(path, keyPair.network);
					var address = this.publicKeyToAddress(child.publicKey, type, keyPair.network);
				} catch (error) {
					return cb(error);
				}
				cb(null, address);
			}, this));
		},

		publicKeyToAddress: function(publicKey, type, constants) {

			if (_.isString(publicKey)) {
				publicKey = bitcoin.ECPair.fromPublicKey(Buffer.from(publicKey, 'hex')).publicKey;
			}

			switch (type) {
				case 'p2wpkh':
					var p2wpkh = bitcoin.payments.p2wpkh({
						network: constants,
						pubkey: publicKey,
					});
					return p2wpkh.address;
				case 'p2wpkh-p2sh':
					var p2sh = bitcoin.payments.p2sh({
						network: constants,
						redeem: bitcoin.payments.p2wpkh({
							network: constants,
							pubkey: publicKey,
						}),
					});
					return p2sh.address;
				case 'p2pkh':
					var p2pkh = bitcoin.payments.p2pkh({
						network: constants,
						pubkey: publicKey,
					});
					return p2pkh.address;
				default:
					throw new Error(app.i18n.t(this.ref + '.address-type-not-supported', { type: type }));
			}
		},

		// Prepare object of network constants (for bitcoinjs-lib).
		getNetworkConstants: function() {

			return _.pick(this.network, 'bech32', 'bip32', 'messagePrefix', 'pubKeyHash', 'scriptHash', 'wif');
		},

		getPath: function(scheme, index) {

			var indexes = this.parseDerivationScheme(scheme);
			return indexes.concat(index).join('/');
		},

		parseDerivationScheme: function(scheme) {

			if (!_.isString(scheme)) {
				throw new Error(app.i18n.t(this.ref + '.invalid-derivation-scheme'));
			}

			var parts = scheme.split('/');

			// Strip the reference to the master key.
			if (parts[0] === 'm') {
				parts = parts.slice(1);
			}

			// Strip the /n place-holder from the end.
			if (_.last(parts) === 'n') {
				parts = parts.slice(0, -1);
			}

			var toIndexRegex = /[^0-9]/g;
			// Hardened keys start at index 2^31.
			var hardenedStartIndex = 0x80000000;
			return _.map(parts, function(part) {
				var isHardened = part.indexOf('\'') !== -1;
				var index = parseInt(part.replace(toIndexRegex, ''));
				if (_.isNaN(index)) {
					throw new Error(app.i18n.t(this.ref + '.invalid-derivation-scheme'));
				}
				if (isHardened) {
					index += hardenedStartIndex;
				}
				return index;
			}, this);
		},

		toBaseUnit: function(value) {

			return Math.ceil((new BigNumber(value)).times(1e8).toNumber());
		},

		fromBaseUnit: function(value) {

			return (new BigNumber(value)).dividedBy(1e8).toString();
		},

		convertAmount: function(amount, rate) {

			var decimals = this.numberFormat.decimals;
			var cryptoAmount = app.models.PaymentRequest.prototype.convertToCryptoAmount(amount, rate, decimals);
			return this.toBaseUnit(cryptoAmount);
		},

		buildTx: function(receivingAddress, value, source, feeRate) {

			var changeAddress = source.address;
			var constants = source.keyPair.network;
			var p2wpkh = bitcoin.payments.p2wpkh({
				pubkey: source.keyPair.publicKey,
				network: constants,
			});
			var p2sh = bitcoin.payments.p2sh({
				redeem: p2wpkh,
				network: constants,
			});
			var sumOfOutputs = _.reduce(source.utxo, function(memo, output) {
				return memo + parseInt(output.value);
			}, 0);
			var ref = this.ref;

			var createRawTxWithFee = function(fee) {
				fee = Math.ceil(fee || 0);
				var txb = new bitcoin.TransactionBuilder(constants);
				_.each(source.utxo, function(output) {
					var txid = output.tx_hash;
					var n = output.tx_pos;
					if (source.type === 'p2wpkh') {
						// p2wpkh:
						txb.addInput(txid, n, null, p2wpkh.output);
					} else {
						// p2pkh and p2wpkh-p2sh:
						txb.addInput(txid, n);
					}
				});
				var changeValue = (sumOfOutputs - value) - fee;
				if (changeValue < 0) {
					throw new Error(app.i18n.t(ref + '.insufficient-funds-to-make-payment'));
				}
				txb.addOutput(receivingAddress, value);
				txb.addOutput(changeAddress, changeValue);
				// Sign each input.
				_.each(source.utxo, function(output, index) {
					if (source.type === 'p2pkh') {
						// p2pkh:
						txb.sign(index, source.keyPair);
					} else if (source.type === 'p2wpkh-p2sh') {
						// p2wpkh-p2sh:
						txb.sign(index, source.keyPair, p2sh.redeem.output, null, output.value);
					} else {
						// p2wpkh:
						txb.sign(index, source.keyPair, null, null, output.value);
					}
				});
				return txb.build().toHex();
			};
			// Build a sample tx so that we can calculate the fee.
			var sampleTx = createRawTxWithFee(0);
			// Calculate the size of the sample tx (in kilobytes).
			var size = sampleTx.length / 2000;
			// The fee rate is satoshis/kilobyte.
			var fee = size * feeRate;
			return createRawTxWithFee(fee);
		},

		payRequestFromPaperWallet: function(paymentRequest, paperWalletData, cb) {

			var receivingAddress = paymentRequest.data.address;
			// NOTE: The amount in the payment request is denominated in the display currency.
			var value = this.convertAmount(
				paymentRequest.amount,
				paymentRequest.rate
			);
			var wif = paperWalletData;
			this.payToAddressFromWIF(receivingAddress, value, wif, cb);
		},

		keyPairFromWIF: function(wif) {

			try {
				var constants = this.getNetworkConstants();
				var keyPair = bitcoin.ECPair.fromWIF(wif, constants);
			} catch (error) {
				app.log(error);
			}

			if (!keyPair) {
				throw new Error(app.i18n.t(this.ref + '.invalid-wif', {
					paymentMethodLabel: this.label,
				}));
			}

			return keyPair || null;
		},

		payToAddressFromWIF: function(receivingAddress, value, wif, cb) {

			try {
				var keyPair = this.keyPairFromWIF(wif);
				var publicKey = Buffer.from(keyPair.publicKey).toString('hex');
				var buildTx = _.bind(this.buildTx, this);
				var broadcastRawTx = _.bind(this.broadcastRawTx, this);
				var getAddressWithFundsGreaterThanOrEqualTo = _.bind(this.getAddressWithFundsGreaterThanOrEqualTo, this);
				var getFeeRate = _.bind(this.getFeeRate, this);
				var ref = this.ref;

				async.parallel({
					source: function(next) {
						getAddressWithFundsGreaterThanOrEqualTo(publicKey, value, next);
					},
					feeRate: function(next) {
						var targetNumberOfBlocks = 72;// !!! TODO !!! Make this configurable?
						getFeeRate(targetNumberOfBlocks, next);
					},
				}, function(error, results) {

					if (error) {
						return cb(error);
					}

					var source = results.source;

					if (!source) {
						return cb(new Error(app.i18n.t(ref + '.insufficient-funds-to-make-payment')));
					}

					try {
						source.keyPair = keyPair;
						var feeRate = results.feeRate;
						var rawTx = buildTx(receivingAddress, value, source, feeRate);
					} catch (error) {
						return cb(error);
					}

					broadcastRawTx(rawTx, function(error, result) {

						if (error) {
							return cb(error);
						}

						if (result && result.txid) {
							var txData = _.pick(result, 'txid');
							return cb(null, txData);
						}

						cb();
					});
				});
			} catch (error) {
				return cb(error);
			}
		},

		listenForPayment: function(paymentRequest, cb) {

			var address = paymentRequest.data && paymentRequest.data.address;
			// NOTE: The amount in the payment request is denominated in the display currency.
			var expectedValue = this.convertAmount(
				paymentRequest.amount,
				paymentRequest.rate
			);
			this.listening = { address: address };

			var done = _.once(_.bind(function(error, txData) {

				this.stopListeningForPayment();

				if (error) {
					// Don't increment the address index in case of an error.
					return cb(error);
				}

				// A payment was received, so increment the address index.
				this.incrementAddressIndex(function() {
					cb(null, txData);
				});

			}, this));

			var isReplaceableTx = _.bind(this.isReplaceableTx, this);
			var constants = this.getNetworkConstants();
			var receivedAmount = 0;
			var onNewTx = function(tx) {
				if (tx) {
					// Sum the value of outputs for the receiving address.
					var amount = _.chain(tx.outs).map(function(out) {
						try {
							var outputAddress = bitcoin.address.fromOutputScript(out.script, constants);
						} catch (error) {
							app.log(error);
							return null;
						}
						if (outputAddress === address) {
							return out.value;
						}
						return null;
					}).compact().reduce(function(memo, value) {
						return memo + value;
					}, 0/* memo */).value();
					receivedAmount += amount;
					if (receivedAmount >= expectedValue) {
						// Passing transaction data so it can be stored.
						var txData = {
							txid: tx.hash,
							isReplaceable: isReplaceableTx(tx),
						};
						return done(null, txData);
					}
				}
			};

			async.until(_.bind(function() {
				return this.isActive();
			}, this), function(next) {
				_.delay(next, 10);
			}, _.bind(function() {
				this.getAddressTxHistory(address, _.bind(function(error, previousHistory) {
					if (error) return done(error);
					var lastStatus;
					this.subscribeToAddressStatus(address, done, _.bind(function(status) {
						if (status && status !== lastStatus) {
							lastStatus = status;
							this.getAddressTxHistory(address, _.bind(function(error, latestHistory) {
								if (!error && latestHistory) {
									var newTxHashes = _.chain(latestHistory).reject(function(tx) {
										return _.some(previousHistory, function(prevTx) {
											return prevTx.tx_hash === tx.tx_hash;
										});
									}).pluck('tx_hash').value();
									previousHistory = latestHistory;
									async.map(newTxHashes, _.bind(this.getTx, this), function(error, newTxes) {
										_.each(newTxes, onNewTx);
									});
								}
							}, this));
						}
					}, this));
				}, this));
			}, this));
		},

		isReplaceableTx: function(tx) {

			// The minimum value is 0 and the maximum value is (2^32 - 1)
			// Any value of sequence that is less than the maximum, can be replaced.
			// NOTE: 2^32 - 2 is also considered non-RBF.
			// This is the max sequence value used by Electrum.
			var maxSequence = BigNumber('2').pow('32').minus('2');
			return _.some(tx.ins, function(input) {
				var sequence = new BigNumber(input.sequence);
				return sequence.lt(maxSequence);
			});
		},

		subscribeToAddressStatus: function(address, onError, onStatus) {

			if (this.addressStatusSubscriptions[address]) {
				throw new Error('Already subscribed to address status: ' + address);
			}
			var electrumService = _.result(this, 'electrumService');
			var constants = this.getNetworkConstants();
			var outputScriptHash = this.getOutputScriptHash(address, constants);
			electrumService.cmd('blockchain.scripthash.subscribe', [outputScriptHash], function(error, status) {
				if (error) {
					if (error.message === 'unknown method "blockchain.scripthash.subscribe"') {
						return electrumService.cmd('blockchain.address.subscribe', [address], function(error, status) {
							if (error) return onError(cb);
							onStatus(status);
						});
					}
					return onError(error);
				} else {
					onStatus(status);
				}
			});
			var clients = electrumService.getConnectedClients();
			var onData = function(data) {
				if (data.method === 'blockchain.scripthash.subscribe' && data.params[0] === outputScriptHash) {
					onStatus(data.params[1]);
				}
			};
			_.invoke(clients, 'on', 'data', onData);
			this.addressStatusSubscriptions[address] = onData;
		},

		unsubscribeToAddressStatus: function(address, cb) {

			var electrumService = _.result(this, 'electrumService');
			var constants = this.getNetworkConstants();
			var outputScriptHash = this.getOutputScriptHash(address, constants);
			electrumService.cmd('blockchain.scripthash.unsubscribe', [outputScriptHash], function(error, result) {
				if (error && error.message === 'unknown method "blockchain.scripthash.unsubscribe"') {
					return electrumService.cmd('blockchain.address.unsubscribe', [address], cb);
				}
				cb(error, result);
			});
			if (this.addressStatusSubscriptions[address]) {
				var clients = electrumService.getConnectedClients();
				var onData = this.addressStatusSubscriptions[address];
				_.invoke(clients, 'off', 'data', onData);
				this.addressStatusSubscriptions[address] = null;
			}
		},

		getTx: function(txHash, cb) {

			var electrumService = _.result(this, 'electrumService');
			electrumService.cmd('blockchain.transaction.get', [txHash], function(error, rawTx) {
				if (error) return cb(error);
				try {
					var tx = bitcoin.Transaction.fromHex(rawTx);
					tx.hash = txHash;
				} catch (error) {
					return cb(error);
				}
				cb(null, tx);
			});
		},

		getFeeRate: function(targetNumberOfBlocks, cb) {

			var toBaseUnit = _.bind(this.toBaseUnit, this);
			var electrumService = _.result(this, 'electrumService');
			electrumService.cmd('blockchain.estimatefee', [targetNumberOfBlocks], function(error, result) {
				if (error) return cb(error);
				// satoshis/kilobyte
				var feeRate = toBaseUnit(result);
				cb(null, feeRate);
			});
		},

		getUnspentTxOutputs: function(publicKey, cb) {

			try {
				var electrumService = _.result(this, 'electrumService');
				var constants = this.getNetworkConstants();
				var tasks = _.map(this.addressTypes, function(type) {
					var address = this.publicKeyToAddress(publicKey, type, constants);
					var outputScriptHash = this.getOutputScriptHash(address, constants);
					return function(next) {
						var cb = function(error, result) {
							if (error) return next(error);
							next(null, {
								address: address,
								type: type,
								utxo: result,
							});
						};
						electrumService.cmd('blockchain.scripthash.listunspent', [outputScriptHash], function(error, result) {
							if (error && error.message === 'unknown method "blockchain.scripthash.listunspent"') {
								return electrumService.cmd('blockchain.address.listunspent', [address], cb);
							}
							cb(error, result);
						});
					};
				}, this);
				async.parallel(tasks, cb);
			} catch (error) {
				return cb(error);
			}
		},

		getAddressTxHistory: function(address, cb) {

			var electrumService = _.result(this, 'electrumService');
			var constants = this.getNetworkConstants();
			var outputScriptHash = this.getOutputScriptHash(address, constants);
			electrumService.cmd('blockchain.scripthash.get_history', [outputScriptHash], cb);
		},

		getAddressWithFundsGreaterThanOrEqualTo: function(publicKey, value, cb) {

			var getUnspentTxOutputs = _.bind(this.getUnspentTxOutputs, this, publicKey);
			var pickAddress = _.bind(this.pickAddressWithFundsGreaterThanOrEqualTo, this);
			async.seq(
				getUnspentTxOutputs,
				function(addresses, next) {
					try {
						var address = pickAddress(addresses, value);
					} catch (error) {
						return next(error);
					}
					next(null, address);
				}
			)(cb);
		},

		pickAddressWithFundsGreaterThanOrEqualTo: function(addresses, value) {

			return _.chain(addresses).compact().map(function(address) {
				address.unspent = _.reduce(address.utxo, function(memo, output) {
					return memo + parseInt(output.value);
				}, 0);
				if (address.unspent < value) return;
				return address;
			}).compact().sortBy(function(address) {
				return address.unspent * -1;
			}).first().value();
		},

		electrumService: function() {

			return app.services.electrum[this.ref];
		},

		isActive: function() {

			var electrumService = _.result(this, 'electrumService');
			return !!electrumService && electrumService.isActive();
		},

		broadcastRawTx: function(rawTx, cb) {

			var electrumService = _.result(this, 'electrumService');
			electrumService.cmd('blockchain.transaction.broadcast', [rawTx], function(error, result) {
				if (error) return cb(error);
				// Success.
				var txid = result[1];
				cb(null, txid);
			});
		},

		stopListeningForPayment: function() {

			if (this.listening) {
				var address = this.listening.address;
				this.unsubscribeToAddressStatus(address, _.noop);
				this.listening = null;
			}
		},

		getOutputScriptHash: function(address, constants) {

			var outputScript = bitcoin.address.toOutputScript(address, constants);
			var hash = bitcoin.crypto.sha256(outputScript);
			return Buffer.from(hash.reverse()).toString('hex');
		},

	});

})();
